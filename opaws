#!/usr/bin/env perl
use Mojolicious::Lite;
use Mojo::Log;
use Mojo::JSON qw(decode_json encode_json);
use Data::Dumper;
my $log = Mojo::Log->new;

# Documentation browser under "/perldoc"
plugin 'PODRenderer';

=head2 routes
  predefined routes and proper handling:
=cut

post '/' => sub {
  my $c = shift;
  my $response;
  my $wscall = $c->req->json;
  my $intent = $wscall->{request}->{intent}->{name};
  my $slots  = $wscall->{request}->{intent}->{slots}; 
  my $src_host = $slots->{src}->{value};
  my $job_id = $slots->{id}->{value};

  $log->debug(Dumper($wscall));

  if ( $intent eq "cloneJob" ) {

    $response = clone_job($job_id, $src_host);
    $log->debug($response);
    
    my $json = generate_json_response($response);
    $log->debug($response);
    
    my $ws_response = decode_json($json);
    $log->debug($ws_response);
    render_json($c, $ws_response);
  } 
  elsif ( $intent eq "restartJob" ) {
    $response = restart_job($job_id, $src_host);
    $log->debug($response);
    
    my $json = generate_json_response($response);
    $log->debug($response);
    
    my $ws_response = decode_json($json);
    $log->debug($ws_response);
    render_json($c, $ws_response);
  }
  $response = undef;
};

=head2 helper functions
  functions for actually interacting with stuff
=cut

sub restart_job {
  my ($job_id, $src_host) = @_;
  $src_host = "https://openqa.".$src_host.".org";
  my $cmd = "/usr/share/openqa/script/client --json-output jobs/$job_id/restart post";
  $log->debug($cmd);
  my $response = `$cmd`;
  $response =~ s/#/Number /;
  ($response) = split /:/, $response;
  return $response;
}

sub clone_job {
  my ($job_id, $src_host) = @_;
  $src_host = "https://openqa.".$src_host.".org";
  my $cmd = "/usr/share/openqa/script/clone_job.pl --host http://openqa.eureka.lab.zarate.net.ve --skip-download --from $src_host $job_id";
  $log->debug($cmd);
  my $response = `$cmd`;
  $response =~ s/#/Number /;
  ($response) = split /:/, $response;
  return $response;
}

sub render_json {
    my ($c, $resp) = @_;
    $c->render(json => $resp);
    $c->rendered(200);
}

sub generate_json_response {
    my $input = shift;
    my $json = '{
       "version": "0.1",
       "response": {
         "outputSpeech": {
           "type": "PlainText",
           "text": "'.$input.'"
         }
       }
     }';
    
     return encode_json($json);
}

app->secrets(["Skynet is comming! :)"]);
app->start;

# All responses should be a combination between json and ssml tags
# https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/speech-synthesis-markup-language-ssml-reference
__DATA__

@@ index.html.ep
% layout 'default';
% title 'OpenQA Alexa Web Service (OpAWS)';
<h1>Welcome to OpAWS</h1>

@@ layouts/default.html.ep
<!DOCTYPE html>
<html>
  <head><title><%= title %></title></head>
  <body><%= content %></body>
</html>
